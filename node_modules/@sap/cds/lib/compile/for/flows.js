// REVISIT: to be moved to cds-compiler later

const cds = require('../../..')

const FLOW_STATUS = '@flow.status'
const FROM = '@from'
const TO = '@to'
// backwards compat
const FLOW_FROM = '@flow.from'
const FLOW_TO = '@flow.to'
const FLOW_PREVIOUS = '$flow.previous'

const getFrom = action => {
  let from = action[FROM] ?? action[FLOW_FROM]
  return Array.isArray(from) ? from : [from]
}

function addOperationAvailableToActions(actions, statusEnum, statusElementName) {
  for (const action of Object.values(actions)) {
    const fromList = getFrom(action)
    const conditions = fromList.map(from => {
      const value = from['#'] ? (statusEnum[from['#']]?.val ?? from['#']) : from
      return `$self.${statusElementName} = ${typeof value === 'string' ? `'${value}'` : value}`
    })
    const condition = `(${conditions.join(' OR ')})`
    const parsedXpr = cds.parse.expr(condition)
    action['@Core.OperationAvailable'] ??= {
      ...parsedXpr,
      ['=']: condition
    }
  }
}

function addSideEffectToActions(actions, statusElementName) {
  for (const action of Object.values(actions)) {
    const properties = []
    if (statusElementName.endsWith('.code')) {
      const baseName = statusElementName.slice(0, -5)
      properties.push(`in/${statusElementName}`)
      properties.push(`in/${baseName}/*`)
      properties.push(`in/${baseName}_code`)
    } else {
      properties.push(`in/${statusElementName}`)
    }
    const sideEffect = '@Common.SideEffects.TargetProperties'
    if (action[sideEffect]) {
      action[sideEffect].push(...properties)
    } else {
      action[sideEffect] = properties
    }
  }
}

function resolveStatusEnum(csn, codeElem) {
  if (codeElem.enum !== undefined) return codeElem.enum
  if (codeElem.type) {
    const typeDef = csn.definitions[codeElem.type]
    return typeDef ? typeDef.enum : undefined
  }
}

function enhanceCSNwithFlowAnnotations4FE(csn) {
  for (const definition of Object.values(csn.definitions)) {
    if (definition.kind !== 'entity') continue
    const entity = definition

    if (!entity.elements || !entity.actions) continue
    for (const [elemName, element] of Object.entries(entity.elements)) {
      if (!element[FLOW_STATUS]) continue

      const fromActions = []
      const toActions = []
      for (const action of Object.values(entity.actions)) {
        if (action[FROM] || action[FLOW_FROM]) fromActions.push(action)
        if (action[TO] || action[FLOW_TO]) toActions.push(action)
      }
      if (fromActions.length === 0 && toActions.length === 0) continue
      if (element.enum) {
        // Element is an enum directly
        addSideEffectToActions(toActions, elemName)
        addOperationAvailableToActions(fromActions, element.enum, elemName)
      } else if (element.target) {
        // Element is an association to a codelist
        const targetDef = csn.definitions[element.target]
        if (targetDef?.elements?.code) {
          const codeElem = targetDef.elements.code
          const statusEnum = resolveStatusEnum(csn, codeElem)
          if (statusEnum) {
            addSideEffectToActions(toActions, elemName + '.code')
            addOperationAvailableToActions(fromActions, statusEnum, elemName + '.code')
          }
        }
      } else if (element['@odata.foreignKey4']) {
        // when compiling to edmx, the foreign key is also annotated with @flow.status, but has no info about the target
        continue
      } else {
        cds.error(
          `Status element in entity ${entity.name} is not an enum and does not have a valid target with code enum.`
        )
      }
    }
  }
}

module.exports = function cds_compile_for_flows(csn) {
  let flowHistory

  for (const name in csn.definitions) {
    const def = csn.definitions[name]

    if (!def.kind || def.kind !== 'entity' || !def.actions || def.elements?.transitions_) continue

    let history
    if (cds.env.features.history_for_flows === 'all') {
      for (const each in def.elements) {
        if (def.elements[each]['@flow.status']) {
          history = true
          break
        }
      }
    } else {
      for (const each in def.actions) {
        const action = def.actions[each]
        if (action && (action[TO]?.['='] === FLOW_PREVIOUS || action[FLOW_TO]?.['='] === FLOW_PREVIOUS)) {
          history = true
          break
        }
      }
    }
    if (!history) continue

    flowHistory ??= csn.definitions['sap.common.FlowHistory']
    if (!flowHistory) cds.error('Cannot find definition sap.common.FlowHistory')

    const { elements: aspectElements } = flowHistory.elements.transitions_.targetAspect

    def.includes ??= []
    def.includes.push('sap.common.FlowHistory')
    def.elements.transitions_ = JSON.parse(`{
      "type": "cds.Composition",
      "cardinality": { "max": "*" },
      "targetAspect": { "elements": ${JSON.stringify(aspectElements)} },
      "target": "${name}.transitions_",
      "on": [{ "ref": ["transitions_", "up_"] }, "=", { "ref": ["$self"] }]
    }`)

    const def_keys = Object.keys(def.elements)
      .filter(k => def.elements[k].key)
      .map(k => ({ ref: [k] }))
    csn.definitions[`${name}.transitions_`] = JSON.parse(`{
      "kind": "entity",
      "elements": {
        "up_": {
          "key": true,
          "type": "cds.Association",
          "cardinality": { "min": 1, "max": 1 },
          "target": "${name}",
          "keys": ${JSON.stringify(def_keys)},
          "notNull": true
        },
        ${JSON.stringify(aspectElements).slice(1, -1)}
      }
    }`)
  }
}

module.exports.enhanceCSNwithFlowAnnotations4FE = enhanceCSNwithFlowAnnotations4FE
module.exports.getFrom = getFrom
