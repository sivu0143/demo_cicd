const cds = require('../../cds')

const { getFrom } = require('../../../../lib/compile/for/flows')

const FLOW_STATUS = '@flow.status'
const FROM = '@from'
const TO = '@to'
// backwards compat
const FLOW_FROM = '@flow.from'
const FLOW_TO = '@flow.to'

const FLOW_PREVIOUS = '$flow.previous'

function buildAllowedCondition(action, statusElementName, statusEnum) {
  const fromList = getFrom(action)
  const conditions = fromList.map(from => {
    const value = from['#'] ? (statusEnum[from['#']]?.val ?? statusEnum[from['#']]['$path'].at(-1)) : from
    return `${statusElementName} = ${typeof value === 'string' ? `'${value}'` : value}`
  })
  return `(${conditions.join(' OR ')})`
}

async function isCurrentStatusInFrom(req, action, statusElementName, statusEnum) {
  const cond = buildAllowedCondition(action, statusElementName, statusEnum)
  const parsedXpr = cds.parse.expr(cond)
  const dbEntity = await SELECT.one.from(req.subject).where(parsedXpr)
  return dbEntity !== undefined
}

async function checkStatus(req, action, statusElementName, statusEnum) {
  const allowed = await isCurrentStatusInFrom(req, action, statusElementName, statusEnum)
  if (!allowed) {
    const from = getFrom(action)
    const fromValues = JSON.stringify(from.flatMap(el => Object.values(el)))
    cds.error({
      code: 409,
      message: from.length > 1 ? 'INVALID_FLOW_TRANSITION_MULTI' : 'INVALID_FLOW_TRANSITION_SINGLE',
      args: [action.name, statusElementName, fromValues]
    })
  }
}

const buildUpKeys = parentKeys => {
  const upKeys = {}
  for (const key in parentKeys) {
    upKeys[`up__${key}`] = parentKeys[key]
  }
  return upKeys
}

const updateFlowHistory = async (req, toValue, upKeys, changes, isPrevious) => {
  if (cds.env.features.flows_history_stack && isPrevious) {
    await DELETE.from(req.target.compositions['transitions_'].target).where({
      timestamp: changes[changes.length - 1].timestamp
    })
  } else {
    await INSERT.into(req.target.compositions['transitions_'].target).entries({
      ...upKeys,
      status: toValue
    })
  }
}

const buildToKey = (action, statusEnum) => {
  const to = action[TO] ?? action[FLOW_TO]
  const toKey = to['#'] ? (statusEnum[to['#']].val ?? statusEnum[to['#']]['$path'].at(-1)) : to
  return toKey
}

const handleStatusTransitionWithHistory = async (req, statusElementName, toKey, service) => {
  let upKeys, changes
  upKeys = buildUpKeys(req.params[0])
  changes = await SELECT.from(req.target.compositions['transitions_'].target)
    .where({ ...upKeys })
    .orderBy('timestamp asc')
  const isPrevious = toKey['='] === FLOW_PREVIOUS
  if (isPrevious) {
    if (changes.length <= 1)
      return cds.error({ code: 409, message: 'No change has been made yet, cannot transition to previous status.' })
    toKey = changes[changes.length - 2].status
  }
  await service.run(UPDATE(req.subject).with({ [statusElementName]: toKey }))
  await updateFlowHistory(req, toKey, upKeys, changes, isPrevious)
}

/**
 * handler registration
 */
module.exports = cds.service.impl(function () {
  const entry = []
  const exit = []

  for (const entity of this.entities) {
    if (!entity.actions || !entity.elements) continue

    const fromActions = []
    const toActions = []
    for (const action of entity.actions) {
      if (action[FROM] || action[FLOW_FROM]) fromActions.push(action)
      if (action[TO] || action[FLOW_TO]) toActions.push(action)
    }
    if (fromActions.length === 0 && toActions.length === 0) continue

    let statusElement = Object.values(entity.elements).find(el => el[FLOW_STATUS])
    if (!statusElement) {
      cds.error({
        code: 409,
        message: `Entity ${entity.name} does not have a status element, but its actions have registered @flow annotations.`
      })
    }

    let statusEnum, statusElementName
    if (statusElement.enum) {
      statusEnum = statusElement.enum
      statusElementName = statusElement.name
    } else if (statusElement?._target?.elements['code']) {
      statusEnum = statusElement._target.elements['code'].enum
      statusElementName = statusElement.name + '_code'
    } else {
      cds.error({
        code: 409,
        message: `Status element in entity ${entity.name} is not an enum and does not have a valid target with code enum.`
      })
    }

    entry.push({ events: fromActions, entity, statusElementName, statusEnum })
    exit.push({ events: toActions, entity, statusElementName, statusEnum })
  }

  this.prepend(function () {
    for (const each of entry) {
      this.before(
        each.events,
        each.entity,
        Object.assign(
          async function handle_entry_state(req) {
            const action = req.target.actions[req.event]
            await checkStatus(req, action, each.statusElementName, each.statusEnum)
          },
          { _initial: true }
        )
      )
    }

    for (const each of exit) {
      async function handle_after_create(res, req) {
        const parentKeys = Object.keys(req.target.keys)
        const entry = {}
        for (let i = 0; i < parentKeys.length; i++) {
          entry[`up__${parentKeys[i]}`] = req.data[parentKeys[i]]
        }
        await INSERT.into(req.target.compositions['transitions_'].target).entries({
          ...entry,
          status: res[each.statusElementName]
        })
      }
      if ('transitions_' in (each.entity.compositions ?? {})) this.after('CREATE', each.entity, handle_after_create)

      async function handle_exit_state(req, next) {
        const res = await next()
        const action = req.target.actions[req.event]
        let toKey = buildToKey(action, each.statusEnum)
        if ('transitions_' in (req.target.compositions ?? {})) {
          await handleStatusTransitionWithHistory(req, each.statusElementName, toKey, this)
        } else {
          await this.run(UPDATE(req.subject).with({ [each.statusElementName]: toKey }))
        }
        return res
      }
      this.on(each.events, each.entity, handle_exit_state)
    }
  })
})
