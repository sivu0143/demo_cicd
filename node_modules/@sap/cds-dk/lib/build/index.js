const fs = require('fs')
const cds = require('../cds')
const BuildTaskEngine = require('./buildTaskEngine')
const Plugin = require('./plugin')
const { BuildError } = require('./util')

module.exports = { build, register, Plugin, BuildError }

// reuse schema definition from cds-rc.js used for package.json code completion
/** @typedef{import('../env/schemas/cds-rc')['$defs']['buildTaskType']['enum'][number]} BuildFor */

// using (string & {}) prevents widening of `'x' | string` to just `string`
/**
 * @typedef {{
 *  clean?: boolean,
 *  outputMode?: number,
 *  for?: BuildFor | (string & {}),
 *  src?: string,
 *  dest?: string,
 *  model?: string[]
 * } & {[key:string]:unknown}} BuildOptions
 */

/**
 * Executes cds build in the directory defined by cds.root.
 *
 * @param {BuildOptions} options - command options as defined by build command.
 */
async function build(options = {}) {
    if (!fs.existsSync(cds.root) || !cds.utils.isdir(cds.root)) {
        throw `Project folder '${cds.root}' does not exist`
    }
    try {
        return await new BuildTaskEngine(options).processTasks()
    } catch (e) {
        if (e instanceof BuildError || e.constructor.name === 'CompilationError') {
            cds._log(e.messages.length ? e.messages : e.message, { 'log-level': options['log-level'] || cds.env['log-level'] })
            console.log('')
            // CompilationError.message also includes the detail messages - do not log twice
            const message = e.constructor.name === 'CompilationError' ? 'CDS compilation failed' : e.messages.length ? e.message : 'CDS build failed'
            throw message
        }
        throw e
    }
}

function register(id, plugin) {
    return require('./plugins').register(id, plugin)
}
