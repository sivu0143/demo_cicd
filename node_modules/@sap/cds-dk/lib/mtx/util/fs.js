const fs = require('fs');
const path = require('path');

async function collectFileContent(filePaths, root) {
    const resultMap = new Map();
    return Promise.all(
        filePaths.map(filePath => fs.promises.readFile(filePath)
                .then(content => resultMap.set(toUnixPath(path.relative(root, filePath)), content.toString('utf-8'))))
    ).then(() => resultMap);
}

/**
 * Returns map of files with content for a given directory
 * @param root  Root directory
 * @param sourceDir Directory to start the traversal
 * @param filter Filter function
 * @returns {Promise.<Map>}
 */
function collectFiles(root, sourceDir, filter) {
    const files = new Map();
    _traverseFileSystem(root, sourceDir, files, filter);

    return files;
}

function _traverseFileSystem(root, sourceDir, files, filter) {
    let absoluteDir = path.resolve(root, sourceDir);
    if (!fs.existsSync(absoluteDir)) {
        return;
    }
    try {
        absoluteDir = fs.realpathSync(absoluteDir);
        fs.readdirSync(absoluteDir)
            .map(subDirEntry => path.join(absoluteDir, subDirEntry))
            .forEach(entry => {
                const stats = fs.statSync(entry)
                if (stats.isDirectory()) {
                    _traverseFileSystem(root, entry, files, filter);
                }
                if (stats.isFile() && (!filter || filter.call(this, entry))) {
                    const fileContent = fs.readFileSync(entry);
                    files.set(toUnixPath(path.relative(root, entry)), fileContent.toString('utf-8'));
                }
            });
    } catch(error) { /* ignored */}
}

/**
 * Converts Windows paths by using unix separators
 * @param aPath a path
 * @returns {string}
 */
function toUnixPath(aPath) {
    return aPath.replace(/\\/g, '/');
}

/**
 * Normalizes filename to os specific format (but does not check for existence)
 * @param {string} filename
 */
function normalizePath(filename) {
    return path.normalize(filename);
}

/**
 * Returns whether a given path is a parent of another path.
 * @param maybeParent a potential parent path
 * @param maybeChild a potential child path
 * @returns {boolean} whether `maybeParent` is a parent path of `maybeChild`
 */
function isParent(maybeParent, maybeChild) {
    return ! path.relative(maybeParent, maybeChild).startsWith('..');
}

/**
 * Searches for a regular expression in a directory tree
 * @param folder directory to search in
 * @param extensions file extensions to search for (use lower-case strings)
 * @param regex regular expression to search for
 * @return {boolean} true if the regular expression was found in a file
 */
function grepQR(folder, extensions, regex) {
    for (const dirent of fs.readdirSync(folder, { withFileTypes: true })) {
        if (dirent.isFile() &&
            extensions.some(x => dirent.name.toLowerCase().endsWith(x))) {
            try {
                if (regex.test(fs.readFileSync(path.join(folder, dirent.name), { encoding: 'utf-8' }))) {
                    return true;
                }
            } catch (error) { /* ignore */ }
        }
        if (dirent.isDirectory() && grepQR(path.join(folder, dirent.name), extensions, regex)) {
            return true;
        }
    }
    return false;
}


module.exports = {
    collectFileContent,
    collectFiles,
    toUnixPath,
    normalizePath,
    isParent,
    grepQR
};
