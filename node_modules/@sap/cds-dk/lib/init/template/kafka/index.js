const cds = require('../../../cds')
const { exists, fs, path } = cds.utils
const { readProject } = require('../../projectReader')
const { merge } = require('../../merge')
const { srv4, kafkaMessaging } = require('../../registries/mta')
const mvn = require('../../mvn')

module.exports = class KafkaTemplate extends require('../../plugin') {

  static help() {
    return 'messaging via Apache Kafka'
  }

  static hasInProduction(env) {
    if (exists('pom.xml')) {
      if (!exists('srv/pom.xml')) return false
      return fs.readFileSync(path.resolve(cds.root, 'srv/pom.xml'), 'utf8').includes('cds-feature-kafka')
    }
    return !!(env.requires?.messaging?.kind === 'kafka')
  }

  async run() {
    const project = readProject()
    const { configFile, isNodejs, isJava } = project
    if (isNodejs) await merge(__dirname, 'files/package.json.hbs').into(configFile, { with: project })
    if (isJava) await mvn.add('kafka')
  }

  async combine() {
    const project = readProject()
    const { addMta, srvPath, addHelm, addHelmUnifiedRuntime } = project

    if (addMta) {
      const srv = srv4(srvPath)
      await merge(__dirname, 'files/mta.yaml.hbs').into('mta.yaml', {
          project,
          additions: [srv, kafkaMessaging],
          relationships: [{
              insert: [kafkaMessaging, 'name'],
              into: [srv, 'requires', 'name']
          }]
      })
    }

    if (addHelm || addHelmUnifiedRuntime) {
      await merge(__dirname, 'files/values.yaml').into('chart/values.yaml')
    }
  }
}
