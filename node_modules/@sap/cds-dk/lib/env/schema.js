function mergePluginSchema(pluginSchema) {
    // contribution points also appear in schema file ./schemas/cds-rc.js
    return {
        into: async (targetSchema) => {
            if (pluginSchema.buildTaskType) {
                targetSchema.$defs?.buildTaskType?.enum?.push(pluginSchema.buildTaskType.name);
                targetSchema.$defs?.buildTaskType?.enumDescriptions?.push(pluginSchema.buildTaskType.description);
                targetSchema._cds_schema_overlays.push('buildTaskType')
            }

            if (pluginSchema.databaseType) {
                targetSchema.$defs?.databaseType?.enum?.push(pluginSchema.databaseType.name);
                targetSchema.$defs?.databaseType?.enumDescriptions?.push(pluginSchema.databaseType.description);
                targetSchema._cds_schema_overlays.push('databaseType')
            }

            if (pluginSchema.cds) {
                if (targetSchema.$defs?.cdsRoot?.properties) {
                    Object.assign(targetSchema.$defs.cdsRoot.properties, pluginSchema.cds)
                    targetSchema._cds_schema_overlays.push('cdsRoot')
                }

                // backwards compatibility
                if (targetSchema.properties) {
                    Object.assign(targetSchema.properties, pluginSchema.cds)
                    targetSchema._cds_schema_overlays.push('root')
                }
            }
        }
    }
}

module.exports = async function overlay4(schemaName) {
    const path = require('path')
    const { merge } = require('../init/merge')

    const cds = require('../cds')
    cds.root = process.cwd()

    const { readJSON } = require('../util/fs')

    let result;
    if (typeof cds.schema?.default4 === 'function') {
        result = await cds.schema.default4(schemaName)
    } else if (cds.env?.schemas?.[schemaName]) {
        // backwards compatibility, fails for invalid json files
        result = await readJSON(cds.env.schemas[schemaName])
    } else {
        throw new Error(`cds ${cds.version} in ${cds.root} does not support schema retrieval.`)
    }

    if (schemaName !== 'cds-rc.json') {
        return result
    }

    const oldTitle = result.title
    const oldDescription = result.description
    result._cds_schema_overlays = []

    try {
        const scheamFile = path.join(__dirname, 'schemas', schemaName.replace(/\.json$/, '.js'))
        const schema = require(scheamFile)

        await merge(schema).into(result)
        result._cds_schema_overlays.push('cdsRoot')

        if (result.properties) {
            // backwards compatibility
            await merge(schema.$defs.cdsRoot.properties).into(result.properties)
            result._cds_schema_overlays.push('root')
        }
    } catch (err) {
        console.error(err.message)
    }

    try {
        const plugins = await cds.plugins;
        if (plugins) {
            for (const [key, { impl }] of Object.entries(plugins)) {
                const pluginPackageJsonFile = path.join(path.dirname(impl), 'package.json')
                try {
                    const pluginPackageJson = require(pluginPackageJsonFile)
                    if (pluginPackageJson.cds?.schema) {
                        await mergePluginSchema(pluginPackageJson.cds.schema).into(result);
                    }
                } catch (err) {
                    if (err.code !== 'ENOENT') {
                        console.error(`Error loading schema from plugin ${key}: ${err.message}`)
                    }
                }
            }
        }
    } catch (err) {
        console.error(err.message)
    }

    result.title = oldTitle
    result.description = oldDescription
    return result
}
