const cds = require('@sap/cds')
const LOG = cds.log('mtx'), DEBUG = cds.debug('mtx'), { read, readdir, path, tar } = cds.utils
const { inspect, promisify } = require('node:util')

const readData = async function (extension, root) {
  await tar.xvz(extension).to(root)

  let extCsn = {}
  try { extCsn = JSON.parse(await read(path.join(root, 'extension.csn'))) }
  catch(e) { if (e.code !== 'ENOENT') throw e }

  let bundles
  try { bundles = await read(path.join(root, 'i18n', 'i18n.json')) }
  catch(e) { if (e.code !== 'ENOENT') throw e }

  const csvs = []
  try {
    const dirents = await readdir(path.join(root, 'data'))
    for (const dirent of dirents) {
      const basename = path.basename(dirent)
      csvs[basename] = await read(path.join(root, 'data', dirent))
    }
  }
  catch(e) { if (e.code !== 'ENOENT') throw e }
  return { extCsn, bundles, csvs }
}

// REVISIT: opt-in/out retry mechanism on runtime layer?
// Sketch: cds.tx({ tenant: 't1', retries: 2 }, ...)
// Not for all error cases a retry is an appropriate handling mechanism (e.g. 403)
// -> error code allow/blocklist

/**
 * @template T
 * @param {() => Promise<T>} fn
 * @param {number} [retryCount=5]
 * @param {number} [initialRetryGap=5000]
 * @returns {Promise<T>}
 */
const retry = async (fn, retryCount = cds.requires.multitenancy?.retries ?? 10, initialRetryGap = 5000) => {
  let errorCount = 0
  let finalError
  let retryGap = initialRetryGap
  while (errorCount < retryCount - 1) {
    try {
      return await fn()
    } catch (e) {
      if (e instanceof TypeError) throw e
      // db unique constraint failure, previously masked as code 400
      if (e.code === 301 || e.message.match(/unique constraint/i)) throw e
      if (e.code === 400) throw e
      if (e.code === 404) throw e
      // REVISIT: ugly -> shouldn't have to code for specific DBs
      if (e.code === 'SQLITE_ERROR') throw e
      if (e.code === 259 && e.sqlState === 'HY000' && /could not find table/i.test(e.message)) throw e
      finalError = e
      errorCount++
      LOG.error('attempt', errorCount, 'errored with', e, '- retrying attempt', errorCount + 1, 'of', retryCount)
      await promisify(setTimeout)(retryGap)
      retryGap *= 1.5
    }
  }
  LOG.error('exceeded maximum number of', retryCount, 'retries')
  throw finalError
}

const t0 = cds.env.requires.multitenancy?.t0 ?? 't0'
let _t0Csn
const t0_ = async (query) => retry(async () => {
  const tX = cds.env.features?.t0wO ? 't0wO' : 't0'
  _t0Csn ??= cds.compile.for.nodejs(
    await cds.load(`${__dirname}/../db/${tX}.cds`, { silent: true })
  )
  return cds.tx({ tenant: t0 }, tx => { tx.model = _t0Csn; return tx.run(query) })
})

async function token(credentials, { query = {}, form = {}, subdomain } = {}) {
  const { clientid, clientsecret, certurl, url, certificate, key } = credentials ?? {}
  const u = new URL(certurl || url)
  if (subdomain) u.hostname = u.hostname.replace(/^[^.]+/, subdomain)
  u.pathname = '/oauth/token'
  Object.entries(query).forEach(([k, v]) => u.searchParams.append(k, v))
  const body = new URLSearchParams({ grant_type: 'client_credentials', client_id: clientid, ...form })
  const headers = { 'Content-Type': 'application/x-www-form-urlencoded', Accept: 'application/json' }
  let raw
  if (certificate) {
    raw = await new Promise((resolve, reject) => {
      const req = require('node:https').request({
        hostname: u.hostname,
        port: u.port || 443,
        path: u.pathname + u.search,
        cert: certificate, key,
        method: 'POST',
        headers
      }, res => {
        const chunks = []
        res.on('data', x => chunks.push(x))
        res.on('end', () => {
          if (res.statusCode >= 200 && res.statusCode < 300) resolve(Buffer.concat(chunks).toString())
          else reject(new Error(Buffer.concat(chunks).toString(), { status: res.statusCode }))
        })
      })
      req.on('error', reject)
      req.end(body.toString())
    })
  } else {
    headers.Authorization = 'Basic ' + Buffer.from(`${clientid}:${clientsecret}`).toString('base64')
    const res = await fetchResiliently(u.toString(), { method: 'POST', headers, body: body.toString() })
    raw = typeof res.data === 'string' ? res.data : JSON.stringify(res.data)
  }
  return raw
}

const maxRetries = cds.requires?.multitenancy?.serviceManager?.retries ?? 3 // compat
async function fetchResiliently(url, req, retriesLeft = maxRetries) {
  req.method ??= 'GET'
  try {
    DEBUG?.('>', req.method.toUpperCase(), url, inspect({
      ...(req.headers && { headers: { ...req.headers, Authorization: req.headers.Authorization?.split(' ')[0] + ' ...' } }),
      ...(req.params && { params: req.params }),
      ...(req.data && { data: req.data })
    }, { depth: 11, compact: false, colors: cds.utils.colors.enabled }))
    let finalUrl = url
    if (req.params && Object.keys(req.params).length) {
      const query = Object.entries(req.params).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&')
      finalUrl += (url.includes('?') ? '&' : '?') + query
    }
    const body = req.body !== undefined ? req.body : (req.data && !['GET', 'HEAD'].includes(req.method) ? JSON.stringify(req.data) : undefined)
    const fetchOptions = { ...req, body }
    const res = await fetch(finalUrl, fetchOptions)
    const { status, statusText } = res
    const headers = Object.fromEntries(res.headers.entries())
    const contentType = res.headers.get('content-type') || ''
    const data = contentType.includes('application/json') ? await res.json() : await res.text()

    if (!res.ok) {
      let msg = [status, statusText, data?.message, typeof data?.error === 'object' ? JSON.stringify(data.error) : data?.error, data?.description, data?.cause].filter(Boolean).join(' – ')
      if (res.status === 429 && res.headers.get('retry-after')) msg += ` – retry after ${res.headers.get('retry-after')}`
      throw Object.assign(new Error(msg), { status, statusText, headers })
    }
    const response = { status, statusText, headers, data }
    DEBUG?.('<', req.method.toUpperCase(), url, status, statusText, inspect(_redacted(data), { depth: 11, colors: cds.utils.colors.enabled }))
    return response
  } catch (error) {
    const { status } = error ?? { status: 500 }
    if (status in { 400: 1, 401: 1, 403: 1, 404: 1, 429: 1, 409: 1 } || retriesLeft === 0) return Promise.reject(error)
    const attempt = maxRetries - retriesLeft + 1
    if (LOG._debug) {
      const e = error.toJSON?.() ?? error
      DEBUG(`fetching ${url} attempt ${attempt} failed with`, {
        ...(e.name && { name: e.name }),
        ...(e.message && { message: e.message }),
        ...(e.description && { description: e.description })
      })
    }
    let delay = 0
    // S-curve instead of exponential backoff to allow for high number of reattempts (∞)
    const maxDelay = 30000, midpoint = 6, steepness = 0.4
    delay = maxDelay * (1 + Math.tanh(steepness * (attempt - midpoint))) / 2
    await new Promise((resolve) => setTimeout(resolve, delay))
    return fetchResiliently(url, req, retriesLeft - 1)
  }
}

const SECRETS = /(passw)|(cert)|(ca)|(secret)|(key)|(access_token)|(imageUrl)/i
/**
 * Masks password-like strings, also reducing clutter in output
 * @param {any} cred - object or array with credentials
 * @returns {any}
 */
function _redacted(cred) {
  if (!cred) return cred
  if (Array.isArray(cred)) return cred.map(c => _redacted(c))
  if (typeof cred === 'object') {
    const newCred = Object.assign({}, cred)
    Object.keys(newCred).forEach(k => (typeof newCred[k] === 'string' && SECRETS.test(k)) ? (newCred[k] = '...') : (newCred[k] = _redacted(newCred[k])))
    return newCred
  }
  return cred
}


module.exports = {
  t0_,
  retry,
  readData,
  token,
  fetchResiliently
}
