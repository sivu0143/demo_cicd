const crypto = require('crypto')
const AbstractContainerManagerClient = require('./ctnr-mgr-base')
const LOG = cds.log('mtx'), DEBUG = cds.debug('mtx|tms')

/**
 * TMSClient class for managing HANA tenants and containers.
 *
 * Missing
 * - handling of UPDATE_SUCCEEDED, UPDATE_IN_PROGRESS, UPDATE_FAILED
 * - support of get all
 */

class TMSClient extends AbstractContainerManagerClient {
  constructor(credentials) {
    super(credentials.uaa)
    this.tmsHost = credentials.baseurl

    this.credentialCache = {}
  }

  static newInstance(credentials) {
    return new TMSClient(credentials)
  }

  // Generate hana-tenant-id as a hash of hana-tenant-name
  // only to avoid collisions
  // not expected to be true later due to potential changes caused by backup/restore etc
  static generateTenantId(hanaTenantName) {
    const hash = crypto.createHash('sha256').update(hanaTenantName).digest('hex')
    return [hash.slice(0, 8), hash.slice(8, 12), hash.slice(12, 16), hash.slice(16, 20), hash.slice(20, 32)].join('-')
  }

  _findValidCredentials(credentialList) {
    if (!Array.isArray(credentialList)) {
      return null
    }
    // Filter credentials with 'CREATE_SUCCEEDED', 'CREATE_IN_PROGRESS', 'UPDATE_IN_PROGRESS' and 'UPDATE_SUCCEEDED' state
    const validCredentials = credentialList.filter(({ state }) => ['CREATE_SUCCEEDED', 'CREATE_IN_PROGRESS', 'UPDATE_IN_PROGRESS', 'UPDATE_SUCCEEDED'].includes(state))
    if (validCredentials.length === 0) {
      return null
    }
    // Sort by createTimestamp (newest first) and return the most recent one
    const sorted = validCredentials.sort((a, b) => {
      return new Date(b.createTimestamp) - new Date(a.createTimestamp)
    })
    const succeeded = sorted.find(c => this._validState(c.state))
    if (succeeded) return succeeded
    return sorted[0]
  }

  // Find container and credentials, return {container, credentials, eTag}
  async findContainerAndCredentials(hanaTenantId, btpTenantName) {
    const response = await this.fetchApi(`/tenants/v2/tenants/${hanaTenantId}/containers?$expand=credentials`, {
      baseURL: `https://${this.tmsHost}`,
      method: 'GET'
    })
    if (response.status === 404) throw new Error('404')
    const data = await response.data
    const container = data.data.find(entry =>
      Array.isArray(entry.labels) &&
      entry.labels.includes(`tenant_id=${btpTenantName}`)
    )
    const credentials = this._findValidCredentials(container?.credentials)
    const eTag = response.headers['etag']
    return { container, credentials, eTag }
  }

  async findHanaTenantContainerAndCredentials(btpTenantName) { // TODO expanding credentials does not work currently, change if available again
    const response = await this.fetchApi(`/tenants/v2/tenants?containerFilter=hassubset(labels,["tenant_id=${btpTenantName}"])&$expand=containers`, {
      baseURL: `https://${this.tmsHost}`,
      method: 'GET'
    })
    if (response.status === 404) throw new Error('404')
    const hanatenant = response.data?.data[0]
    if (!hanatenant?.containers) throw Object.assign(new Error(`No container found for tenant ${btpTenantName}`), { status: 404 })
    let eTag = response.headers['etag']
    let container = hanatenant.containers.find(entry =>
      Array.isArray(entry.labels) &&
      entry.labels.includes(`tenant_id=${btpTenantName}`)
    )
    // workaround section
    if (container) {
      ({ container, eTag } = await this.checkCreationStatus({ hanaTenantId: hanatenant.id, container, expand: true }))
    }
    // end workaround section
    // const credentials = container?.credentials // does not work currently
    const credentials = this._findValidCredentials(container?.credentials)
    return { hanatenant, container, credentials, eTag }
  }

  // only internal use
  async findHanaTenant(hanaTenantPrefix, hanaTenantName) {
    const response = await this.fetchApi(`/tenants/v2/tenants?$filter=hassubset(labels,["name=${this._hanaTenantLabel(hanaTenantName)}","prefix=${this._hanaTenantLabel(hanaTenantPrefix)}"])`, {
      baseURL: `https://${this.tmsHost}`,
      method: 'GET'
    })
    if (response.status === 404 || !response.data?.data[0]) throw Object.assign(new Error(`No hana tenant found for hana tenant name ${hanaTenantName}`), { status: 404 })
    const eTag = response.headers['etag']
    return { hanatenant: response.data?.data[0], eTag }
  }

  async createHanaTenant(createOptions) {
    const response = await this.fetchApi(`/tenants/v2/tenants/${createOptions.hanaTenantId}`, {
      baseURL: `https://${this.tmsHost}`,
      method: 'PUT',
      data: {
        ...createOptions.tmsOptions,
        labels: createOptions.labels
      }
    })
    return response.headers['location']
  }

  async getHanaTenant(hanaTenantId) {
    const response = await this.fetchApi(`/tenants/v2/tenants/${hanaTenantId}`, {
      baseURL: `https://${this.tmsHost}`,
      method: 'GET'
    })
    return response.data
  }


  // Check creation status
  // handles two variants: either location or existing ids
  checkCreationStatus = async ({ location, hanaTenantId, container, credentials, expand = false }) => {

    let url = location ? `https://${this.tmsHost}${location}` : `https://${this.tmsHost}/tenants/v2/tenants/${hanaTenantId}`
    if (!location) {
      if (this._validState(credentials?.state)) {
        return { credentials }
      }
      if (!credentials && !expand && this._validState(container?.status?.state)) {
        return { container }
      }
      if (container) url += `/containers/${container.id}`
      if (credentials) url += `/credentials/${credentials.id}`
    }
    const conf = expand ? { params: { $expand: !container ? 'containers/credentials' : 'credentials' } } : undefined
    const response = await this._poll(url, conf).catch(error => { throw error })
    const data = await response.data
    const eTag = response.headers['etag']
    return { container: container ? data : undefined, credentials: credentials ? data : undefined, data, eTag }
  }

  // poll helpers
  _validState(state) {
      return ['CREATE_SUCCEEDED', 'UPDATE_SUCCEEDED'].includes(state)
  }

  _succeeded = (response) => this._validState(response.data?.state) || response.data?.status?.ready
  _failed = (response) => response.data?.state === 'CREATE_FAILED'
  _pollError = (response) => response

  async createContainer(hanaTenantId, btpTenantName, eTag) {
    const url = `https://${this.tmsHost}/tenants/v2/tenants/${hanaTenantId}/containers`
    const options = {
      method: 'POST',
      headers: {
        'if-match': eTag,
      },
      data: { type: 'hdi', labels: [`tenant_id=${btpTenantName}`] }
    }
    try {
      const response = await this.fetchApi(url, options)
      const location = response.headers['location']
      return { location }
    } catch (error) {
      if (error.status === 409) {
        const statusObj = await this.checkCreationStatus({ hanaTenantId, expand: true })
        if (statusObj.data?.containers?.length > 0) {
          const container = statusObj.data.containers.find(c => c.labels?.includes(`tenant_id=${btpTenantName}`))
          if (container) {
            const credentials = this._findValidCredentials(container.credentials)
            return { container, credentials }
          }
        }
        eTag = statusObj.eTag
        return this.createContainer(hanaTenantId, btpTenantName, eTag)
      } else {
        throw error
      }
    }
  }

  // REVISIT 409? -> not a problem if more than one valid credentials exist
  async createCredentials(hanaTenantId, containerId) {
    const url = `https://${this.tmsHost}/tenants/v2/tenants/${hanaTenantId}/containers/${containerId}/credentials`
    const options = {
      method: 'POST',
      data: {},
    }
    const response = await this.fetchApi(url, options)
    return response.headers['location']
  }

  async deleteCredentials(hanaTenantId, containerId, credentialsId) {
    const url = `https://${this.tmsHost}/tenants/v2/tenants/${hanaTenantId}/containers/${containerId}/credentials/${credentialsId}`
    const options = {
      method: 'DELETE',
    }
    const response = await this.fetchApi(url, options)
    return response.headers['location']
  }

  async deleteContainer(hanaTenantId, containerId) {
    const url = `https://${this.tmsHost}/tenants/v2/tenants/${hanaTenantId}/containers/${containerId}`
    const options = {
      method: 'DELETE'
    }
    const response = await this.fetchApi(url, options)
    return response.headers['location']
  }

  async deleteHanaTenant(hanaTenantId, tenant) {
    const url = `https://${this.tmsHost}/tenants/v2/tenants/${hanaTenantId}`
    const options = {
      method: 'DELETE'
    }
    const response = await this.fetchApi(url, options)
    try {
      await this.checkCreationStatus({ location: response.headers['location'] })
    } catch (error) { // expect 404
      if (error.status === 404) {
        DEBUG?.('Finished deleting hana tenant', tenant ?  ' for tenant ' : '', tenant ?? hanaTenantId, ':', error)
      } else {
        LOG.error('Error deleting hana tenant ', tenant ?  ' for tenant ' : '', tenant ?? hanaTenantId, ':', error)
        throw error
      }
    }
    return true
  }

  get = async (tenant, options = { disableCache: false }) => {
    if (!tenant) throw new Error('Tenant name is required')
    if (options.disableCache || !this.credentialCache[tenant]) {
      const { container, credentials } = await this.findHanaTenantContainerAndCredentials(tenant)
      if (!container || !credentials || !container.status?.ready || credentials.state === 'DELETE_IN_PROGRESS') {
        DEBUG?.('Container or credentials not found for tenant', tenant)
        const cds = require('@sap/cds')
        cds.error(`Tenant '${tenant}' does not exist`, { status: 404 })
      }
      this.credentialCache[tenant] = { credentials, tags: ['hana'] }
    }
    return this.credentialCache[tenant]
  }

  getAll = async (tenants, options) => {
    if (tenants === '*') throw new Error('getAll for "*" not implemented for TMSv2.') // still block '*' for now
    if (!tenants) {
      return this._getAll()
    }
    const results = []
    for (const tenant of tenants) {
      const credentials = await this.get(tenant, options)
      if (credentials) {
        results.push({ tenant, credentials })
      }
    }
    return results
  }

   async _getAllHanaTenants() {
    const all = []
    let skiptoken
    do {
      const response = await this.fetchApi(`/tenants/v2/tenants?${skiptoken ? `&$skiptoken=${skiptoken}` : ''}`, {
        baseURL: `https://${this.tmsHost}`,
        method: 'GET'
      })
      all.push(...response.data.data)
      skiptoken = response.data.$skiptoken
    } while (skiptoken)
    return all
  }

  async _getAll() {
    const all = []
    let skiptoken
    do {
      const response = await this.fetchApi(`/tenants/v2/tenants?$expand=containers/credentials${skiptoken ? `&$skiptoken=${skiptoken}` : ''}`, {
        baseURL: `https://${this.tmsHost}`,
        method: 'GET'
      })
      all.push(...response.data.data.map(item => {
        // Extract lastTransitionTimestamp from hana tenant status
        const updated_at = item.status?.lastTransitionTimestamp
        // Extract tenant_id from container labels
        const containers = (item.containers ?? [])
          .filter(container => (container.labels?.[0] ?? '').startsWith('tenant_id='))
          .map(container => { return { tenant_id: container.labels[0].split('=')[1], credentials: container.credentials }})

        return containers.length > 0 ? {
          labels: {
            tenant_id: containers.map(c => c.tenant_id)
          },
          updated_at,
          credentials: this._findValidCredentials(containers[0].credentials)
        } : undefined
      }))
      skiptoken = response.data.$skiptoken
    } while (skiptoken)
    return all.filter(item => item !== undefined)
  }

  /**
   * Create a new HANA tenant and its HDI container with credentials
   */
  create = async (btpTenantName, parameters) => {
    const createOptions = this._createOptions(btpTenantName, parameters?.create || {}, this.defaultHanaTenantPrefix)
    let hanaTenantId = createOptions.hanaTenantId
    let container, credentials, eTag
    try {
      ({ hanatenant: { id: hanaTenantId }, container, credentials, eTag } = await this.findHanaTenantContainerAndCredentials(btpTenantName)) // find by btpTenantName only - hanaTenantId is not guaranteed
      // If credentials are found and ready, return
      if (credentials) {
        return (await this.checkCreationStatus({hanaTenantId, container, credentials})).credentials
      }
    } catch (err) {
      if (err.status === 404) {
        // No HANA tenant found, create it
        // What about 409 -> not specified. Using PUT with generated id instead
        const location = await this.createHanaTenant(createOptions)
        // Wait until tenant is ready and extract eTag
        const response = await this.checkCreationStatus({ location })
        eTag = response.eTag
      } else throw err
    }

    if (!container) {
      const { location: containerLocation, container: newContainer } = await this.createContainer(hanaTenantId, btpTenantName, eTag)
      const response = await this.checkCreationStatus({ location: containerLocation, hanaTenantId, container: newContainer })
      container = response.container || response.data
    } else {
      ({ container } = await this.checkCreationStatus({ hanaTenantId, container, expand: true }))
    }
    // check potentially existing credentials
    credentials = this._findValidCredentials(container?.credentials)
    let credentialsLocation
    if (!credentials) {
      credentialsLocation = await this.createCredentials(hanaTenantId, container.id)
    }
    const response = await this.checkCreationStatus({ location: credentialsLocation, hanaTenantId, container, credentials })
    credentials = response.credentials || response.data // return credentials or data depending on what is available
    this.credentialCache[btpTenantName] = { credentials, tags: ['hana'] }
    return this.credentialCache[btpTenantName]
  }

  remove = async (tenant, parameters) => {
    const { cleanup_hana_tenants: cleanupHanaTenants} = parameters?.create || {}
    try {
      const { hanatenant: { id: hanaTenantId }, container } = await this.findHanaTenantContainerAndCredentials(tenant)
      if (!container) return
      // Delete credentials
      const credentials = container.credentials || []
      const deletions = credentials.map(async cred => {
        const location = await this.deleteCredentials(hanaTenantId, container.id, cred.id)
        try {
          await this.checkCreationStatus({ location })
        } catch (error) { // expect 404
          DEBUG?.('Finished deleting credentials for tenant', tenant, ':', error)
        }
      })
      await Promise.all(deletions)
      delete this.credentialCache[tenant]

      // Delete container
      const location = await this.deleteContainer(hanaTenantId, container.id)
      try {
        await this.checkCreationStatus({ location })
      } catch (error) { // expect 404
        if (error.status === 404) {
          DEBUG?.('Finished deleting container for tenant', tenant, ':', error)
        } else {
          LOG.error('Error deleting container for tenant', tenant, ':', error)
          throw error
        }
      }

      // Delete hana tenant if requested
      if (!cleanupHanaTenants) return
      await this.deleteHanaTenant(hanaTenantId, tenant)
    } catch (error) {
      if (error.status === 404) {
        DEBUG?.('Container for tenant', tenant, 'not found, nothing to delete')
      } else {
        LOG.error('Error deleting container for tenant', tenant, ':', error)
        throw error
      }
    }
  }

  delete = this.remove

  _createParams = (tenant, params = {}, metadata) => {
    const final = this._hdiParams(tenant, params, metadata) ?? {}

    const { database_id, ...tenantParams } = final?.create ?? {}
    final.create = { serviceInstanceID: database_id, ...tenantParams }

    return Object.keys(final).length > 0 ? final : null
  }

  // REVISIT exception?
  _hanaTenantLabel(label) {
    return label.length > 63 ? label.substring(0, 60) + '...' : label
  }

  _createOptions = (btpTenantName, params) => {
    // eslint-disable-next-line no-unused-vars
    const { hana_tenant_id, hana_tenant_name, hana_tenant_prefix, cleanup_hana_tenants, ...cleanOptions } = params
    const validTMSOptions = ['dataEncryption', 'serviceInstanceID', 'labels']
    for (const key of Object.keys(cleanOptions)) {
      if (!validTMSOptions.includes(key)) {
        delete cleanOptions[key]
      }
    }
    const labels = []
    let hanaTenantId = hana_tenant_id
    let hanaTenantPrefix = hana_tenant_prefix
    if (!hanaTenantId) {
      if (!hanaTenantPrefix) {
        // if (!this.defaultHanaTenantPrefix) throw new Error('No default prefix for hana tenant name configured, cannot generate a unique hana tenant name.')
        // hanaTenantPrefix = this.defaultHanaTenantPrefix // crypto.createHash('sha256').update(this.defaultHanaTenantPrefix).digest('hex').substring(0, 20)
        throw new Error('No default prefix for hana tenant name configured, cannot generate a unique hana tenant name.')
      }
      hanaTenantId = TMSClient.generateTenantId(`${hanaTenantPrefix}-${btpTenantName}`)
      // push labels
      labels.push(`prefix=${this._hanaTenantLabel(hanaTenantPrefix)}`, `name=${this._hanaTenantLabel(btpTenantName)}`)
    } else {
      // TODO check if hanaTenantId is valid uuid
    }

    return { hanaTenantPrefix, hanaTenantName: btpTenantName, hanaTenantId, labels, tmsOptions: cleanOptions, cleanupHanaTenants: cleanup_hana_tenants }
  }

  _encryptionParams = () => {
    return {}
  }

}

module.exports = TMSClient
