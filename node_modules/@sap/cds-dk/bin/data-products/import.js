#!/usr/bin/env node
const cds = require ('../../lib/cds.js')
const { write, path } = cds.utils
const { Export } = require ('../export.js')


class Import extends Export {

  options = Import.options // for IntelliSense
  static options = { ...super.options,
    to: './apis/imported/*',
    'data-product': false,
  }
  static filename = __filename;

  usage() {
    const md = path.join(__dirname, '../help/import.md')
    return super.usage = cds.utils.fs.readFileSync (md,'utf8')
  }

  async load (sources, o = this.options) {
    if (!o['data-product']) return super.load (sources)
    if (!sources || sources[0] === '*') return this.help()
    const { load_data_product } = require ('./index.js')
    return load_data_product (sources,o)
  }

  export_to (o = this.options) {
    if (!o.apiResourceOrdId) return super.export_to (o)
    this.package_name = o.apiResourceOrdId.replace(':apiResource:','-').replaceAll(':','-').replaceAll('.','-').toLowerCase()
    return this.options.to.slice(0,-1) + this.package_name
  }

  *export_texts() {
    const bundles = this.csn.i18n; if (!bundles) return
    const serialize = texts => Object.entries(texts).map(([k,v]) => k +'='+ v.replace(/'/g, "''")).join('\n')
    const write = texts => ({ to: file => this.write(serialize(texts)).to(file) })
    for (let [locale,texts] of Object.entries(bundles))
      yield write(texts) .to (`_i18n/i18n_${locale}.properties`)
  }

  *export_models (model, o = this.options) {

    // If no data product ID is specified, fall back to the default export behavior
    if (!o.apiResourceOrdId) return yield* super.export_models(model, o);

    const normalizeEOL = process.platform === 'win32' ? (str) => str.replace(/\r?\n/g, EOL) : str => str;
    const {EOL} = require ('node:os')

    const { definitions, extensions } = model;
    yield this.write (
      `// This file acts as a central facade to exported service definitions.`+ EOL +
      `// You can modify it to tweak things, without your changes being overridden.`+ EOL +
      `using from './services';`+
      (extensions ? EOL + `using from './annotations';` : '')
    ) .to ('index.cds')

    const definitionsCdl = cds.compile.to.cdl ({definitions}, {renderCdlCommonNamespace:false})
    yield this.write (normalizeEOL(definitionsCdl)) .to ('services.cds')

    if (extensions) {
      // shorten names in the "annotate" to match the local name defined in "using"
      const services = Object.keys(definitions).filter (k => definitions[k].kind === 'service')
      if (services.length === 1 && services[0].includes('.')) {
        let prefix = services[0].substring(0, services[0].lastIndexOf('.'))  + '.'
        extensions.forEach(o => {o.annotate = o.annotate.replace(prefix, '') })
      }

      let annotationsCdl = cds.compile.to.cdl ({extensions: extensions});

      if (services.length === 1)
        annotationsCdl = `using { ${services[0]} } from './services';` + EOL + EOL + annotationsCdl

      yield this.write (normalizeEOL(annotationsCdl)) .to ('annotations.cds')
    }
    // TODO: What does this do? Do we need it or also remove it?
    o.data = false;
  }

  async export_package_json (o = this.options) {

    // If no data product ID is specified, fall back to the default export behavior
    if (!o.apiResourceOrdId) return super.export_package_json(o)

    const [,major,minor=0,patch=0] = o.apiResourceOrdId.match(/v(\d+)(?:\.(\d+)(?:\.(\d+))?)?/)
    const srv = o.apiResourceOrdId.replace(':apiResource:','.').replaceAll(':','.')

    await super.export_package_json ({
      name: this.package_name,
      version: major + '.' + minor + '.' + patch,
      cds: {
        requires: {
          [srv]: {
            kind: 'data.product',
            model: this.package_name,
            ordId: o.apiResourceOrdId
          }
        }
      }
    })

    return this.update_package_json();
  }

  async update_package_json(){
    const rootPackageJsonPath = path.join(cds.root + '/package.json');
    const rootPackageJson = require(rootPackageJsonPath);
    rootPackageJson.dependencies = rootPackageJson.dependencies || {};
    rootPackageJson.dependencies[this.package_name] = `file:${this.options.to}`;
    await write(rootPackageJson).to(rootPackageJsonPath);
  }
}

module.exports = Object.assign (Import._for_cds_dk(), { Import })
